dark times: [datetime.datetime(2024, 10, 18, 1, 56, 29)]
##      Running in sequence      ##
2024-10-21 18:50:01.170404 Opening: /home/agirmen/research_data/Colibri_Raw_Minute_Test/ColibriData/20241018/20241019_01.56.31.674
current date: 2024-10-18 01:56:31
using dark from: 2024-10-18 01:56:29
2024-10-21 18:50:01.224911 Imported 2399 frames
2024-10-21 18:50:01.224948 Checking GPS lock for  20241019_01.56.31.674
GPS Control Block: 96
Starfinding in field17...
Weighting Radius for Starfinding (GaussSigma) = 0.7742919590715063
Drift (x,y): -0.023730499669909477 px/s, 0.00015717283531557769 px/s
/home/agirmen/research_data/Colibri_Raw_Minute_Test/ColibriData/20241018/20241019_01.56.31.674 No drift
Negative flux: star 21
2024-10-21 18:51:32.812317 Rejected Stars:  100.0 %
2024-10-21 18:51:32.812336 Total stars in field: 37
2024-10-21 18:51:32.812338 Candidate events in this minute: 0
2024-10-21 18:51:32.812341 Closing: /home/agirmen/research_data/Colibri_Raw_Minute_Test/ColibriData/20241018/20241019_01.56.31.674


Wrote profile results to colibri_main_py3.py.lprof
Timer unit: 1e-06 s

Total time: 79.1063 s
File: /home/agirmen/Github/ColibriPipeline-Tonys-version/ColibriPipeline/colibri_image_reader_python.py
Function: importFramesRCD at line 168

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   168                                           @profile
   169                                           def importFramesRCD(image_paths,
   170                                                               start_frame=0, 
   171                                                               num_frames=1,
   172                                                               dark=np.zeros((1,1),dtype=np.float64)):
   173                                               """
   174                                               Reads in frames from .rcd files starting at a specific frame.
   175                                               
   176                                                   Parameters:
   177                                                       image_paths (Path): pathlib object of image paths to read in
   178                                                       start_frame (int): Starting frame number
   179                                                       num_frames (int): How many frames to read in
   180                                                       dark (arr): 2D array of fluxes from dark image
   181                                                       
   182                                                   Returns:
   183                                                       img_array (arr): Image data
   184                                                       img_times (list): Header times of these images
   185                                               """
   186                                           
   187                                               
   188                                               
   189                                               ## Define pixel dimension of the square image and the memory array and list
   190       244        286.9      1.2      0.0      IMG_DIM = 2048
   191       244      11807.9     48.4      0.0      img_array = np.zeros((num_frames, IMG_DIM, IMG_DIM), dtype=np.float64)
   192       244        269.5      1.1      0.0      img_times = []
   193                                               
   194                                               ## Define end frame. Then evaluate if this is larger than the array
   195                                               ## Loop which iteratively reads in the files and processes them
   196       244        153.0      0.6      0.0      frame = 0
   197       244        260.8      1.1      0.0      end_frame = start_frame + num_frames
   198                                               #print(f"Start = {start_frame}; End = {end_frame}; Len = {len(image_paths)}")
   199       244        737.7      3.0      0.0      if end_frame > len(image_paths):
   200                                                   for fname in image_paths[start_frame:]:
   201                                                       #print(frame)
   202                                                       
   203                                                       # Load in the image data and header timestamp and subtract the dark
   204                                                       data,timestamp = readRCD(fname)
   205                                                       image = split_images(conv_12to16(data), IMG_DIM, IMG_DIM)
   206                                                       
   207                                                       # Timestamp formatted as YYYY-MM-DDThh:mm:ss.dddddddddZ
   208                                                       # Roll over the time if it exceeded 24h
   209                                                       hour = timestamp.split('T')[1].split(':')[0]
   210                                                       if int(hour) > 23:
   211                                                           timestamp = timestamp.replace('T' + hour, 'T' + str(int(hour) % 24))
   212                                                       
   213                                                       # Add corrected image and time data to appropriate array/list
   214                                                       img_array[frame] = image
   215                                                       img_times.append(timestamp)
   216                                                       frame += 1
   217                                                   UserWarning("Not enough frames in given list to import")
   218                                                       
   219       244        273.1      1.1      0.0      elif end_frame == len(image_paths):
   220        11         39.9      3.6      0.0          for fname in image_paths[start_frame:]:
   221                                                       #print(frame)
   222                                                       
   223                                                       # Load in the image data and header timestamp and subtract the dark
   224         9     125293.8  13921.5      0.2              data,timestamp = readRCD(fname)
   225         9      18725.3   2080.6      0.0              image = split_images(conv_12to16(data), IMG_DIM, IMG_DIM)
   226                                                       
   227                                                       # Timestamp formatted as YYYY-MM-DDThh:mm:ss.dddddddddZ
   228                                                       # Roll over the time if it exceeded 24h
   229         9         59.3      6.6      0.0              hour = timestamp.split('T')[1].split(':')[0]
   230         9         56.4      6.3      0.0              if int(hour) > 23:
   231                                                           timestamp = timestamp.replace('T' + hour, 'T' + str(int(hour) % 24))
   232                                                       
   233                                                       # Add corrected image and time data to appropriate array/list
   234         9      74396.6   8266.3      0.1              img_array[frame] = image
   235         9         70.7      7.9      0.0              img_times.append(timestamp)
   236         9         30.7      3.4      0.0              frame += 1
   237         2         11.4      5.7      0.0          UserWarning("At end of given list of frames")
   238                                               
   239                                               else:
   240      2651       8350.1      3.1      0.0          for fname in image_paths[start_frame:end_frame]:
   241                                                       #print(frame)
   242                                                       
   243                                                       # Load in the image data and header timestamp and subtract the dark
   244      2409   22747488.4   9442.7     28.8              data,timestamp = readRCD(fname)
   245      2409    4806342.7   1995.2      6.1              image = split_images(conv_12to16(data), IMG_DIM, IMG_DIM)
   246                                                       
   247                                                       # Timestamp formatted as YYYY-MM-DDThh:mm:ss.dddddddddZ
   248                                                       # Roll over the time if it exceeded 24h
   249      2409      14078.7      5.8      0.0              hour = timestamp.split('T')[1].split(':')[0]
   250      2409      13027.4      5.4      0.0              if int(hour) > 23:
   251                                                           timestamp = timestamp.replace('T' + hour, 'T' + str(int(hour) % 24))
   252                                                       
   253                                                       # Add corrected image and time data to appropriate array/list
   254      2409   13877192.6   5760.6     17.5              img_array[frame] = image
   255      2409      16973.4      7.0      0.0              img_times.append(timestamp)
   256      2409       8459.4      3.5      0.0              frame += 1
   257                                                       
   258                                               
   259       244   37380738.1 153199.7     47.3      img_array = np.subtract(img_array, dark, dtype=np.float64)
   260                                               
   261                                               ## Check if only one frame was called: if so, ndim=3 -> ndim=2
   262       244        797.1      3.3      0.0      if num_frames == 1:
   263         2         12.0      6.0      0.0          return img_array[0],img_times
   264                                               else:
   265       242        409.9      1.7      0.0          return img_array,img_times           

Total time: 91.6879 s
File: ColibriPipeline/colibri_main_py3.py
Function: firstOccSearch at line 215

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   215                                           @profile
   216                                           def firstOccSearch(minuteDir, MasterDarkList, kernel, exposure_time, sigma_threshold,
   217                                                              base_path,obs_date,
   218                                                              telescope='TEST',RCDfiles = True, gain_high = True):
   219                                               """ 
   220                                               Formerly 'main'.
   221                                               Detect possible occultation events in selected file and archive results 
   222                                               
   223                                                   Parameters:
   224                                                       minuteDir (str): Filepath to current directory
   225                                                       MasterDarkList (list): List of master darks and times
   226                                                       kernel (arr): Ricker wavelet kernel
   227                                                       exposure_time (int/float): Camera exposure time (in s)
   228                                                       sigma_threshold (float): Sensitivity of the detection filter
   229                                                       base_path (str): Path to root directory containing Archive and Data
   230                                                       obs_date (str): Date of observation (as marked on the data 
   231                                                                       directory to be analyzed)
   232                                                   
   233                                                   Returns:
   234                                                       __ (str): Printout of processing tasks
   235                                                       __ (.npy): .npy format file with star positions (if doesn't exist)
   236                                                       __ (.txt): .txt format file for each occultation event with names
   237                                                                  of images to be saved
   238                                                       __ (int/float): time of saved occultation event images
   239                                                       __ (float): flux of occulted star in saved images
   240                                                       star_count (int): Number of detected stars in the given minuteDir
   241                                               """
   242                                           
   243                                           
   244                                           ###########################
   245                                           ## Analysis Setup
   246                                           ###########################
   247                                           
   248         1         20.1     20.1      0.0      print (f"{datetime.datetime.now()} Opening: {minuteDir}")
   249                                           
   250                                               ## Create folder for results
   251         1         39.7     39.7      0.0      savefolder = base_path.joinpath('ColibriArchive', str(obs_date))
   252         1         19.5     19.5      0.0      if not savefolder.exists():
   253                                                   savefolder.mkdir()      
   254                                           
   255                                               ## Select and load the master dark closest in time to the current minute
   256         1      37871.4  37871.4      0.0      dark = cir.chooseDark(minuteDir, MasterDarkList, obs_date)
   257                                           
   258                                               ## Get a sorted list of images in this minute directory, ignoring the first
   259                                               ## due to vignetting
   260         1      16504.9  16504.9      0.0      imagePaths = sorted(minuteDir.glob('*.rcd'))     
   261         1          4.3      4.3      0.0      del imagePaths[0]
   262                                                   
   263                                               ## Idenitify important characteristics from name and length of images list
   264         1         11.5     11.5      0.0      field_name = imagePaths[0].name.split('_')[0]  #which of 24 fields are observed
   265         1          6.0      6.0      0.0      x_length, y_length, num_images = cir.getSizeRCD(imagePaths)
   266                                           
   267         1         28.4     28.4      0.0      print(datetime.datetime.now(), "Imported", num_images, "frames")
   268                                               
   269                                               ## Check if there are enough images in the current directory 
   270         1          7.1      7.1      0.0      minNumImages = len(kernel.array)*3         #3x kernel length
   271         1          1.3      1.3      0.0      if num_images < minNumImages:
   272                                                   print(datetime.datetime.now(), "Insufficient number of images, skipping...")
   273                                                   return minuteDir.name, 0, 0
   274                                               
   275                                               ## Check if there is a valid GPS lock
   276         1          4.1      4.1      0.0      print(datetime.datetime.now(), "Checking GPS lock for ", minuteDir.name)
   277         1         70.3     70.3      0.0      if not cir.testGPSLock(imagePaths[0]):
   278                                                   print(datetime.datetime.now(), "No GPS Lock established, skipping...")
   279                                                   return minuteDir.name, 0, 0
   280                                               
   281                                           
   282                                           ###########################
   283                                           ## Star Identification
   284                                           ###########################
   285                                               
   286                                               #print (datetime.datetime.now(), field_name, 'starfinding...',)
   287         1          2.0      2.0      0.0      print(f"Starfinding in {field_name}...")
   288                                               
   289                                               ## Create median combined image for star finding
   290         1          1.4      1.4      0.0      try:
   291         1    1831454.3    2e+06      2.0          stacked = cir.stackImages(minuteDir, savefolder, NUM_TO_SKIP, NUM_TO_STACK, dark)
   292                                               ## Prevents program from crashing if there are corrupt images
   293                                               except UnicodeDecodeError:
   294                                                   print(f"ERROR: UnicodeDecodeError in {minuteDir.name}")
   295                                                   return minuteDir.name, 0, 0
   296                                           
   297                                               ## Make list of star coords and half light radii using a conservative
   298                                               ## threshold scaled to the number of images stacked
   299         1      47447.7  47447.7      0.1      star_find_results = tuple(cp.initialFind(stacked, DETECT_THRESH*NUM_TO_STACK**0.5))
   300                                           
   301                                               ## Remove stars where centre is too close to edge of frame
   302         1          2.6      2.6      0.0      edge_buffer = 10     #number of pixels between edge of star aperture and edge of image
   303                                               #star_find_results = tuple(x for x in star_find_results if x[0] + AP_R + edge_buffer < x_length and x[0] - AP_R - edge_buffer > 0)
   304                                               #star_find_results = tuple(y for y in star_find_results if y[1] + AP_R + edge_buffer < x_length and y[1] - AP_R - edge_buffer > 0)
   305         1         25.5     25.5      0.0      star_find_results = tuple(x for x in star_find_results if x[0] + edge_buffer < x_length and x[0] - edge_buffer > 0)
   306         1         10.3     10.3      0.0      star_find_results = tuple(y for y in star_find_results if y[1] + edge_buffer < x_length and y[1] - edge_buffer > 0)
   307                                           
   308                                           
   309                                               ## Save the array of star positions as an .npy file
   310                                               ## Format: x  |  y  | half light radius
   311         1          2.5      2.5      0.0      if len(star_find_results) >= NPY_STARS:
   312         1         77.0     77.0      0.0          star_pos_file = base_path.joinpath('ColibriArchive', str(obs_date), minuteDir.name + '_' + str(DETECT_THRESH) + 'sig_pos.npy')
   313         1         38.3     38.3      0.0          if star_pos_file.exists():
   314         1        261.1    261.1      0.0              star_pos_file.unlink()
   315         1        280.4    280.4      0.0          np.save(star_pos_file, star_find_results)
   316                                           
   317                                           
   318                                               ## Enforce a minimum number of visible stars in each image
   319         1          1.0      1.0      0.0      if len(star_find_results) < MIN_STARS:
   320                                                   print(f"Insufficient stars in minute: {minuteDir}")
   321                                                   print (f"{datetime.datetime.now()} Closing: {minuteDir}")
   322                                                   print ("\n")
   323                                                   return minuteDir.name, len(star_find_results), 0
   324                                                   
   325                                               ## Seperate radii and positions in separate arrays
   326         1         11.8     11.8      0.0      star_find_results = np.array(star_find_results)
   327         1          2.2      2.2      0.0      radii = star_find_results[:,-1]
   328         1          1.4      1.4      0.0      initial_positions = star_find_results[:,:-1]
   329                                           
   330                                               ## Number of stars identified in image
   331         1          1.4      1.4      0.0      num_stars = len(initial_positions)
   332                                               
   333                                               
   334                                           ###########################
   335                                           ## Drift Calculations
   336                                           ########################### 
   337                                           
   338                                               ## Initialize centroid refining parameters
   339         1         16.2     16.2      0.0      drift_pos = np.empty([2, num_stars], dtype = (np.float64, 2))  #array to hold first and last positions
   340         1         75.4     75.4      0.0      GaussSigma = np.mean(radii * 2. / 2.35)  # calculate gaussian sigma for each star's light profile
   341         1         10.7     10.7      0.0      print(f"Weighting Radius for Starfinding (GaussSigma) = {GaussSigma}")
   342                                           
   343                                               ## Import the first frame and last frame for starfinding purposes
   344         1      17721.0  17721.0      0.0      fframe_data,fframe_time = cir.importFramesRCD(imagePaths, NUM_TO_SKIP, 1, dark)   #import first image
   345         1      65967.9  65967.9      0.1      lframe_data,lframe_time = cir.importFramesRCD(imagePaths, len(imagePaths)-1, 1, dark)  #import last image
   346         1          0.6      0.6      0.0      headerTimes = [fframe_time] #list of image header times
   347                                           
   348                                               ## Refine star positions for first and last image (also returns frame times)
   349         1       2081.4   2081.4      0.0      first_drift = cp.refineCentroid(fframe_data,fframe_time[0], initial_positions, GaussSigma)
   350         1        302.9    302.9      0.0      last_drift = cp.refineCentroid(lframe_data,lframe_time[0], first_drift[0], GaussSigma*DRIFT_MULT)
   351                                           
   352                                               ## Organize frame times and centroid positions into containers
   353         1          5.0      5.0      0.0      drift_pos[0] = first_drift[0]  # first frame positions
   354         1          1.4      1.4      0.0      drift_pos[1] = last_drift[0]  # last frame positions
   355         1          1.7      1.7      0.0      drift_times = [first_drift[1], last_drift[1]]  # frame times
   356         1       1846.4   1846.4      0.0      drift_times = Time(drift_times, precision=9).unix  # convert times to unix
   357                                           
   358                                               ## Calculate median drift rate [px/s] in x and y over the minute
   359         1        223.5    223.5      0.0      x_drift, y_drift = cp.averageDrift(drift_pos[0],drift_pos[1], drift_times[0],drift_times[1])
   360         1         10.2     10.2      0.0      print(f"Drift (x,y): {x_drift} px/s, {y_drift} px/s")
   361                                               
   362                                               ## Decide whether to apply drift modifications to frame analysis using a
   363                                               ## tolerence threshold. If the drift values are too large, disregard this
   364                                               ## minute as a tracking error. Rates in px/s.
   365         1          1.2      1.2      0.0      if abs(x_drift) > MAX_DRIFT or abs(y_drift) > MAX_DRIFT:
   366                                                   print (f"{datetime.datetime.now()} Significant drift. Skipping {minuteDir}...") 
   367                                                   return minuteDir.name, num_stars, 0
   368         1          0.5      0.5      0.0      elif abs(x_drift) > DRIFT_TOL or abs(y_drift) > DRIFT_TOL:
   369                                                   drift = True # variable to check whether stars have drifted since last frame
   370                                               else:
   371         1          0.2      0.2      0.0          drift = False
   372                                           
   373                                           
   374                                           ###########################
   375                                           ## Flux Measurements
   376                                           ########################### 
   377                                           
   378                                               ## Define the container containing the flux measurements of all images
   379                                               ## with each frame holding a ( num_stars * 4 ) sized array.
   380                                               ## [0] x coorinate; [1] y coordinate; [2] flux; [3] frame time
   381         1          2.5      2.5      0.0      starData = np.empty((num_images, num_stars, 4), dtype=np.float64)
   382                                               
   383                                               ## Fill the first data frame with information from the first image
   384         2         24.2     12.1      0.0      starData[0] = tuple(zip(initial_positions[:,0], 
   385         1          0.7      0.7      0.0                          initial_positions[:,1], 
   386                                                                   #sumFlux(first_frame[0], initial_positions[:,0], initial_positions[:,1], AP_R),
   387                                                                   # (sep.sum_circle(fframe_data, initial_positions[:,0], initial_positions[:,1], AP_R)[0]).tolist(),
   388         1        603.9    603.9      0.0                          (sep.sum_circle(fframe_data, initial_positions[:,0], initial_positions[:,1], AP_R)[0]).tolist(),
   389         1        459.1    459.1      0.0                          np.ones(np.shape(np.array(initial_positions))[0]) * (Time(fframe_time, precision=9).unix)))
   390                                           
   391                                           
   392                                               ## Iteratively process the images and put the results into starData
   393         1          0.3      0.3      0.0      if drift:  # If drift compensation is required, enter this loop
   394                                               
   395                                                   print(f"{minuteDir} Drifted - applying drift to photometry {x_drift} {y_drift}")
   396                                                   
   397                                                   # Loop through each image in the minute-long dataset in chunks
   398                                                   residual   = (num_images-1)%CHUNK_SIZE
   399                                                   for i in range((num_images-1)//CHUNK_SIZE):
   400                                                       # Read in the images in a given chunk
   401                                                       imageFile,imageTime = cir.importFramesRCD(imagePaths,CHUNK_SIZE*i+1, CHUNK_SIZE, dark)
   402                                                       headerTimes = headerTimes + imageTime
   403                                                       for j in range(CHUNK_SIZE):
   404                                                           # Process the images in the current chunk
   405                                                           starData[CHUNK_SIZE*i+j+1] = cp.timeEvolve(imageFile[j],
   406                                                                                                       deepcopy(starData[CHUNK_SIZE*i+j]),
   407                                                                                                       imageTime[j],
   408                                                                                                       AP_R,
   409                                                                                                       num_stars,
   410                                                                                                       (x_length, y_length),
   411                                                                                                       (x_drift, y_drift))
   412                                                           gc.collect()
   413                                                       
   414                                                   # Read in the remaining images
   415                                                   imageFile,imageTime = cir.importFramesRCD(imagePaths,
   416                                                                                             num_images-residual,
   417                                                                                             residual,
   418                                                                                             dark)
   419                                                   headerTimes = headerTimes + imageTime
   420                                                   
   421                                                   # Process the remaining images
   422                                                   for i in range(residual+1)[:0:-1]:
   423                                                       starData[num_images-i] = cp.timeEvolve(imageFile[residual-i],
   424                                                                                               deepcopy(starData[num_images-i-1]),
   425                                                                                               imageTime[residual-i],
   426                                                                                               AP_R,
   427                                                                                               num_stars,
   428                                                                                               (x_length, y_length),
   429                                                                                               (x_drift, y_drift))        
   430                                                   gc.collect()
   431                                                   
   432                                                       
   433                                               else:  # if there is not significant drift, don't account for drift  in photometry
   434                                                   
   435         1          8.6      8.6      0.0          print(f'{minuteDir} No drift')
   436                                                   
   437                                                   # Loop through each image in the minute-long dataset in chunks
   438         1          0.7      0.7      0.0          residual   = (num_images-1)%CHUNK_SIZE
   439       240        670.3      2.8      0.0          for i in range((num_images-1)//CHUNK_SIZE):
   440                                                       # Read in the images in a given chunk
   441       239   75428133.1 315598.9     82.3              imageFile,imageTime = cir.importFramesRCD(imagePaths,CHUNK_SIZE*i+1, CHUNK_SIZE, dark)
   442       239       3936.4     16.5      0.0              headerTimes = headerTimes + imageTime
   443                                                       # Process the the current chunk all at once
   444       478     659224.3   1379.1      0.7              starData[CHUNK_SIZE*i+1:CHUNK_SIZE*(i+1)+1] = cp.getStationaryFlux(imageFile,
   445       239      13782.9     57.7      0.0                                                                                 deepcopy(starData[CHUNK_SIZE*i]),
   446       239        154.2      0.6      0.0                                                                                 imageTime,
   447       239        198.7      0.8      0.0                                                                                 AP_R,
   448       239        133.9      0.6      0.0                                                                                 num_stars,
   449       239         94.7      0.4      0.0                                                                                 (x_length, y_length))
   450                                                           
   451       239   13181346.5  55152.1     14.4              gc.collect()
   452                                                       
   453                                                   # Read in the remaining images
   454         2     246486.8 123243.4      0.3          imageFile,imageTime = cir.importFramesRCD(imagePaths,
   455         1          2.6      2.6      0.0                                                    num_images-(num_images-1)%CHUNK_SIZE,
   456         1          0.5      0.5      0.0                                                    (num_images-1)%CHUNK_SIZE,
   457         1          0.2      0.2      0.0                                                    dark)
   458         1         30.0     30.0      0.0          headerTimes = headerTimes + imageTime
   459                                                   # Process the residual chunk
   460         2       2299.3   1149.7      0.0          starData[num_images-residual:] = cp.getStationaryFlux(imageFile,
   461         1         54.7     54.7      0.0                                                                deepcopy(starData[num_images-residual-1]),
   462         1          0.3      0.3      0.0                                                                imageTime,
   463         1          1.1      1.1      0.0                                                                AP_R,
   464         1          0.5      0.5      0.0                                                                num_stars,
   465         1          0.3      0.3      0.0                                                                (x_length, y_length))
   466                                                           
   467         1      51221.3  51221.3      0.1          gc.collect()
   468                                               
   469                                           
   470                                               """
   471                                               # Roman's photometry plotting section
   472                                               import matplotlib.pyplot as plt
   473                                               for starNum in range(0,num_stars):
   474                                               flux=starData[:, starNum, 2]
   475                                               x_coords_in=starData[0][starNum][0]
   476                                               y_coords_in=starData[0][starNum][1]
   477                                               x_coords_fi=starData[-1][starNum][0]
   478                                               y_coords_fi=starData[-1][starNum][1]
   479                                               fig, ax1 = plt.subplots()
   480                                               ax1.scatter(range(0,len(starData)), flux,label="initial pos: x="+str(x_coords_in)+" y="+str(y_coords_in)+"\n final pos: x="+str(x_coords_fi)+" y="+str(y_coords_fi))
   481                                               plt.legend()
   482                                               plot_path=base_path.joinpath('ColibriArchive', str(obs_date), minuteDir.name)
   483                                               if not os.path.exists(plot_path):
   484                                                   os.mkdir(plot_path)
   485                                               plt.savefig(plot_path.joinpath('_star_'+str(i) + '.png'))
   486                                               
   487                                               plt.close()
   488                                               for i in range(len(starData[0])):
   489                                                   flux=[]
   490                                                   frame=[]
   491                                                   x_coords_in=starData[0][i][0]
   492                                                   y_coords_in=starData[0][i][1]
   493                                                   x_coords_fi=starData[-1][i][0]
   494                                                   y_coords_fi=starData[-1][i][1]
   495                                                   for j in range(len(starData)):
   496                                                       flux.append(starData[j][i][2])
   497                                                       frame.append(j)
   498                                                       
   499                                                   
   500                                                   fig, ax1 = plt.subplots()
   501                                                   ax1.scatter(frame, flux,label="initial pos: x="+str(x_coords_in)+" y="+str(y_coords_in)+"\n final pos: x="+str(x_coords_fi)+" y="+str(y_coords_fi))
   502                                                   plt.legend()
   503                                                   plot_path=base_path.joinpath('ColibriArchive', str(obs_date), minuteDir.name)
   504                                                   if not os.path.exists(plot_path):
   505                                                       os.mkdir(plot_path)
   506                                                   plt.savefig(plot_path.joinpath('_star_'+str(i) + '.png'))
   507                                                   
   508                                                   plt.close()
   509                                               """
   510                                           
   511                                           
   512                                           
   513                                           ###########################
   514                                           ## Dip Detection
   515                                           ###########################
   516                                              
   517                                               #loop through each detected object
   518         2      25463.8  12731.9      0.0      dipResults = np.array([cp.dipDetection(starData[:, starNum, 2], kernel, starNum, sigma_threshold) for starNum in range(0,num_stars)],
   519         1          0.8      0.8      0.0                            dtype=object)
   520                                              
   521                                               
   522         1          1.0      1.0      0.0      event_frames = dipResults[:,0]         #array of event frames (-1 if no event detected, -2 if incomplete data)
   523         1          0.4      0.4      0.0      light_curves = dipResults[:,1]         #array of light curves (empty if no event detected)
   524                                               
   525         1          0.3      0.3      0.0      conv_flux=dipResults[:,2]              #array of convolved light curves (empty if no event detected)
   526         1          0.3      0.3      0.0      lightcurve_std=dipResults[:,3]          #std of minute-long lightcurve
   527         1          0.4      0.4      0.0      lightcurve_mean= dipResults[:,4]        #mean of minute-long lightcurve
   528         1          0.3      0.3      0.0      Bkg_std= dipResults[:,5]                #std of convolved flux background
   529         1          0.3      0.3      0.0      Bkg_mean= dipResults[:,6]               #mean of convolved flux background
   530         1          0.3      0.3      0.0      conv_min= dipResults[:,7]               #minimum value of the convolution
   531         1          0.4      0.4      0.0      significance=dipResults[:,8]          #significance of the event x*sigma
   532                                           
   533                                               ''' data archival '''
   534                                           
   535         1         54.1     54.1      0.0      save_frames = event_frames[np.where(event_frames > 0)]  #frame numbers for each event to be saved
   536         1          2.6      2.6      0.0      save_chunk = int(round(EVENT_WIDTH / exposure_time))  #save certain num of frames on both sides of event
   537         1          4.8      4.8      0.0      save_curves = light_curves[np.where(event_frames > 0)]  #light curves for each star to be saved
   538                                               #save_types = dip_types[np.where(event_frames > 0)]
   539                                               
   540         1          2.4      2.4      0.0      save_conv_flux=conv_flux[np.where(event_frames > 0)]    #save convolved flux for each event
   541         1          2.2      2.2      0.0      save_lc_std=lightcurve_std[np.where(event_frames > 0)]  #save lightcurve std for each event
   542         1          1.9      1.9      0.0      save_lc_mean=lightcurve_mean[np.where(event_frames > 0)]#save lightcurve mean
   543         1          1.9      1.9      0.0      save_bkg_std=Bkg_std[np.where(event_frames > 0)]        #save background std of convolved lightcurve
   544         1          1.9      1.9      0.0      save_bkg_mean=Bkg_mean[np.where(event_frames > 0)]      #save background mean of convolved lightcurve
   545         1          2.0      2.0      0.0      save_minVal=conv_min[np.where(event_frames > 0)]        #save minimum value of the convolution
   546         1          2.0      2.0      0.0      save_sigma=significance[np.where(event_frames > 0)]     #save significance of each event
   547                                           
   548                                               #loop through each detected event
   549         1          0.3      0.3      0.0      j=0
   550         1          2.5      2.5      0.0      for f in save_frames:
   551                                                   
   552                                                   date = headerTimes[f].split('T')[0]                                 #date of event
   553                                                   time = headerTimes[f].split('T')[1].split('.')[0].replace(':','')   #time of event
   554                                                   star_coords = initial_positions[np.where(event_frames == f)[0][0]]     #coords of occulted star
   555                                                   mstime = headerTimes[f].split('T')[1].split('.')[1]                 # micros time of event
   556                                                  # print(datetime.datetime.now(), ' saving event in frame', f)
   557                                                   
   558                                                   star_all_flux = save_curves[np.where(save_frames == f)][0]  #total light curve for current occulted star
   559                                                   star_all_conv=save_conv_flux[np.where(save_frames == f)][0] #total convolved light curve for current occulted star
   560                                                   #text file to save results in
   561                                                   #saved file format: 'det_date_time_star#_telescope.txt'
   562                                           
   563                                                   savefile = base_path.joinpath('ColibriArchive', str(obs_date), ''.join(('det_', date, '_', time, '_', mstime, '_star', str(np.where(event_frames == f)[0][0]), '_', telescope, '.txt')))
   564                                                   #columns: fits filename and path | header time (seconds) |  star flux
   565                                                   
   566                                                   #open file to save results
   567                                                   # with open(savefile, 'w') as filehandle:
   568                                                       
   569                                                   #     #file header
   570                                                   #     filehandle.write('#\n#\n#\n#\n')
   571                                                   #     filehandle.write('#    Event File: %s\n' %(imagePaths[f]))
   572                                                   #     filehandle.write('#    Star Coords: %f %f\n' %(star_coords[0], star_coords[1]))
   573                                                   #     filehandle.write('#    DATE-OBS: %s\n' %(headerTimes[f]))
   574                                                   #     filehandle.write('#    Telescope: %s\n' %(telescope))
   575                                                   #     filehandle.write('#    Field: %s\n' %(field_name))
   576                                                   #     filehandle.write('#    Dip Type: %s\n' %(save_types[np.where(save_frames == f)][0]))
   577                                                   #     filehandle.write('#    Median Flux: %.2f\n' %(np.median(star_all_flux)))
   578                                                   #     filehandle.write('#    Stddev Flux: %.3f\n' %(np.std(star_all_flux)))
   579                                                   #     filehandle.write('#\n#\n#\n')
   580                                                   #     filehandle.write('#filename     time      flux\n')
   581                                                   
   582                                                   with open(savefile, 'w') as filehandle:
   583                                                       
   584                                                       #file header
   585                                                       filehandle.write('#\n#\n#\n#\n')
   586                                                       filehandle.write('#    Event File: %s\n' %(imagePaths[f]))
   587                                                       filehandle.write('#    Star Coords: %f %f\n' %(star_coords[0], star_coords[1]))
   588                                                       filehandle.write('#\n')
   589                                                       filehandle.write('#    DATE-OBS: %s\n' %(headerTimes[f]))
   590                                                       filehandle.write('#    Telescope: %s\n' %(telescope))
   591                                                       filehandle.write('#    Field: %s\n' %(field_name))
   592                                                       filehandle.write('#    significance: %.3f\n' %(save_sigma[j]))
   593                                                       filehandle.write('#    Raw lightcurve std: %.4f\n' %(save_lc_std[j]))
   594                                                       filehandle.write('#    Raw lightcurve mean: %.4f\n' %(save_lc_mean[j]))
   595                                                       filehandle.write('#    Convolution background std: %.4f\n' %(save_bkg_std[j]))
   596                                                       filehandle.write('#    Convolution background mean: %.4f\n' %(save_bkg_mean[j]))
   597                                                       filehandle.write('#    Convolution minimal value: %.4f\n' %(save_minVal[j]))
   598                                                       filehandle.write('#\n#\n')
   599                                                       filehandle.write('#filename     time      flux     conv_flux\n')
   600                                                      
   601                                                       ''' save data '''
   602                                                       j=j+1
   603                                                      #if the portion of the light curve is at the beginning, start at 0th image
   604                                                       if f - save_chunk <= 0:  
   605                                                   
   606                                                           files_to_save = [imagePath for i, imagePath in enumerate(imagePaths) if i >= 0 and i < f + save_chunk]  #list of filenames to save
   607                                                           star_save_flux = star_all_flux[np.where(np.in1d(imagePaths, files_to_save))[0]]                         #part of light curve to save
   608                                                           star_save_conv= star_all_conv[np.where(np.in1d(imagePaths, files_to_save))[0]]
   609                                                           
   610                                                           #loop through each frame to be saved
   611                                                           for i in range(0, len(files_to_save)):  
   612                                                               filehandle.write('%s %f  %f  %f\n' % (files_to_save[i], float(headerTimes[:f + save_chunk][i].split(':')[2].split('Z')[0]), star_save_flux[i], star_save_conv[i]))
   613                                                       
   614                                                       #if portion of light curve to save is not at the beginning
   615                                                       else:
   616                                                           
   617                                                           #if the portion of the light curve to save is at the end of the minute, end at the last image
   618                                                           if f + save_chunk >= num_images:
   619                                                   
   620                                                               files_to_save = [imagePath for i, imagePath in enumerate(imagePaths) if i >= f - save_chunk]    #list of filenames to save (RAB 042222)
   621                                                               star_save_flux = star_all_flux[np.where(np.in1d(imagePaths, files_to_save))[0]]                                                     #part of light curve to save
   622                                                               star_save_conv= star_all_conv[np.where(np.in1d(imagePaths, files_to_save))[0]]
   623                                                               
   624                                                               #loop through each frame to save
   625                                                               for i in range(0, len(files_to_save)): 
   626                                                                   filehandle.write('%s %f %f  %f\n' % (files_to_save[i], float(headerTimes[f - save_chunk:][i].split(':')[2].split('Z')[0]), star_save_flux[i], star_save_conv[i]))
   627                                           
   628                                                           #if the portion of the light curve to save is not at beginning or end of the minute, save the whole portion around the event
   629                                                           else:  
   630                                           
   631                                                               files_to_save = [imagePath for i, imagePath in enumerate(imagePaths) if i >= f - save_chunk and i < f + save_chunk]     #list of filenames to save
   632                                                               star_save_flux = star_all_flux[np.where(np.in1d(imagePaths, files_to_save))[0]]                                         #part of light curve to save                    
   633                                                               star_save_conv= star_all_conv[np.where(np.in1d(imagePaths, files_to_save))[0]]
   634                                                               
   635                                                               #loop through each frame to save
   636                                                               for i in range(0, len(files_to_save)): 
   637                                                                   filehandle.write('%s %f %f  %f\n' % (files_to_save[i], float(headerTimes[f - save_chunk:f + save_chunk][i].split(':')[2].split('Z')[0]), star_save_flux[i], star_save_conv[i]))
   638                                           
   639                                           
   640                                           
   641                                               ''' printout statements'''
   642         1         22.3     22.3      0.0      print (datetime.datetime.now(), "Rejected Stars: ", round(((num_stars - len(save_frames)) / num_stars)*100, 2), "%")
   643         1          2.1      2.1      0.0      print (datetime.datetime.now(), "Total stars in field:", num_stars)
   644         1          2.5      2.5      0.0      print (datetime.datetime.now(), "Candidate events in this minute:", len(save_frames))
   645         1          6.0      6.0      0.0      print (datetime.datetime.now(), "Closing:", minuteDir)
   646         1          0.4      0.4      0.0      print ("\n")
   647                                           
   648                                               #print("Drift calcs",c3)
   649                                               
   650                                               # return number of stars in field
   651         1      50907.2  50907.2      0.1      gc.collect()
   652         1         14.5     14.5      0.0      return minuteDir.name, num_stars, len(save_frames)

